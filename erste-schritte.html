<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="keywords" content="">

    <title>Docker Doc(k) — Kurs setzen - Erste Schritte</title>

    <!-- Styles -->
    <link href="assets/css/page.min.css" rel="stylesheet">
    <link href="assets/css/style.css" rel="stylesheet">

    <!-- Favicons -->
    <link rel="apple-touch-icon" href="assets/img/apple-touch-icon.png">
    <link rel="icon" href="assets/img/favicon.png">
  </head>

  <body data-spy="scroll" data-target=".nav-sidebar" data-offset="100">


   <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark navbar-stick-dark" data-navbar="sticky">
      <div class="container">

        <div class="navbar-left">
          <button class="navbar-toggler" type="button">&#9776;</button>
          <a class="navbar-brand" href="index.html">
            <img class="logo-dark" src="assets/img/logo-dark.png" alt="logo">
            <img class="logo-light" src="assets/img/logo-light.png" alt="logo">
          </a>
        </div>

        <section class="navbar-mobile">
          <span class="navbar-divider d-mobile-none"></span>

          <ul class="nav nav-navbar">
            <li class="nav-item">
              <a class="nav-link" href="was-ist-docker.html">Was ist Docker? <span class="arrow"></span></a>
              <nav class="nav">
                <a class="nav-link" href="was-ist-docker.html#definition">Definition</a>
                <a class="nav-link" href="was-ist-docker.html#reason">Warum Docker?</a>
                <a class="nav-link" href="was-ist-docker.html#use">Wer nutzt Docker?</a>
              </nav>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="erste-schritte.html">Erste Schritte <span class="arrow"></span></a>
              <ul class="nav">
                <li class="nav-item">
                  <a class="nav-link" href="erste-schritte.html#setup">Docker einrichten</a>
                  <a class="nav-link" href="erste-schritte.html#images">Images und Container</a>
                  <a class="nav-link" href="erste-schritte.html#helloworld">Hello World</a>
                  <a class="nav-link" href="erste-schritte.html#bind_mounts">Bind Mounts</a>
                  <a class="nav-link" href="erste-schritte.html#volumes">Volumes</a>
                  <a class="nav-link" href="erste-schritte.html#dockerfile">Dockerfiles</a>
                </li>
              </ul>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="weiterfuehrendes.html">Weiterführendes <span class="arrow"></span></a>
              <ul class="nav">
                <li class="nav-item">
                  <a class="nav-link" href="weiterfuehrendes.html#docker-compose">Composer</a>
                  <a class="nav-link" href="weiterfuehrendes.html#swarm">Docker Swarm</a>
                  <a class="nav-link" href="weiterfuehrendes.html#gui">GUI in Docker</a>
                </li>
              </ul>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="hilfe.html">Hilfe <span class="arrow"></span></a>
              <nav class="nav">
                <a class="nav-link" href="hilfe.html#faq">FAQ</a>
                <a class="nav-link" href="hilfe.html#glossar">Glossar</a>
                <a class="nav-link" href="hilfe.html#commands">Häufige Kommandos</a>
              </nav>
            </li>
          </ul>
        </section>

      </div>
    </nav><!-- /.navbar -->



    <!-- Header -->
    <header class="header" style="background-color: #f1f6fa">
      <div class="container">
        <h1>Kurs setzen - Erste Schritte</h1>
        <p class="lead">Nach dem theoretischen Einstieg geht es auf dieser Seite nun praktisch los. Nach der Einrichtung von Docker können schon die ersten Container ausgeführt werden.</p>
      </div>
    </header><!-- /.header -->


    <!-- Main Content -->
    <main class="main-content">
      <div class="container">
        <div class="row">


          <!--
          |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
          | Sidebar
          |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
          !-->
          <div class="col-md-4 col-xl-3">
            <aside class="sidebar sidebar-expand-md sidebar-sticky pr-md-4 br-1">
              <div class="sidebar-body">
                <ul class="nav nav-sidebar nav-sidebar-hero nav-sidebar-pill">
                  <li class="nav-item">
                    <a class="nav-link" href="#setup">Docker einrichten <i class="nav-angle"></i></a>
                    <div class="nav">
                      <a class="nav-link" href="#setup_u1">Linux Installation</a>
                      <a class="nav-link" href="#setup_u2">Windows/Mac Installation</a>
                    </div>
                  </li>
                  
                  <li class="nav-item">
                    <a class="nav-link" href="#images">Images und Container</a>
                  </li>
                  
                  <li class="nav-item">
                    <a class="nav-link" href="#helloworld">Hello World</a>
                  </li>
                  
                  <li class="nav-item">
                    <a class="nav-link" href="#image_erstellen">Image erstellen</a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="#bind_mounts">Bind-Mounts</a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="#volumes">Volumes<i class="nav-angle"></i></a>
                    <div class="nav">
                      <a class="nav-link" href="#volumes_u1">Erstellen und verwalten</a>
                      <a class="nav-link" href="#volumes_u2">Mit Container starten</a>
                      <a class="nav-link" href="#volumes_u3">Volume befüllen</a>
                      <a class="nav-link" href="#volumes_u4">Volumes entfernen</a>
                    </div>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="#dockerfile">Dockerfile</a>
                  </li>
                </ul>
              </div>
            </aside>
          </div>


          <!--
          |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
          | Docker einrichten
          |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
          !-->
          <div class="col-md-7 col-xl-8 ml-md-auto py-8">
            <h2 id="setup">Docker einrichten</h2>
            <p class="lead-2">Im folgenden Kapitel erfährst du, wie Docker auf den gängigen Betriebssystemen installiert wird.</p>


            <hr class="hr-dash my-7">


            <h3 id="setup_u1">Docker auf Linux installieren</h3>
              <h4>Möglichkeit 1 - Per Installationsskript</h4>
                <p>Am einfachsten und sichersten kannst du Docker auf deinem Linux-Rechner per installations-script einrichten.  Lade das Installationsskript einfach mit folgendem Befehl per cURL auf deinen Rechner:</p>
                  <pre><code class="language-bash">$ curl -fsSL https://get.docker.com -o get-docker.sh</code></pre>
                <p>Solltest du noch kein cURL auf deinem Rechner installiert haben kannst du es per apt herunterladen. Hierfür solltest du zunächst schauen, ob dein apt-system aktuell ist und im Anschluss die Installation von cURL ausführen:</p>
                  <pre class="line-numbers"><code class="language-bash">
                    $ sudo apt-get update
                    $ sudo apt-get install curl</code></pre>
                <p>Wenn du nun per <code>$ ls</code>  dein aktuelles Verzeichnis durchsuchst solltest du das Installationsscript (get-docker.sh) entdecken. Führe dies zur Installation nun mit Root-Rechten aus:</p>
                  <pre><code class="language-bash">$ sudo sh get-docker.sh</code></pre>
                <p>Nun sollte Docker installiert sein, damit du auch als normaler User Docker benutzen kannst, füge den aktuellen Benutzer zur Gruppe Docker hinzu (anschließend einmal ab- und anmelden dass Änderungen übernommen werden):</p>
                  <pre><code class="language-bash">$ sudo usermod -aG docker $USER</code></pre>
                <p>Als letzten Schritt solltest du noch Docker Compose installieren, dies wird benötigt, um später Docker-Setups mit vielen Containern zu betreiben (Aktuelle Version beachten).</p>
                  <pre><code class="language-bash">$ sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname-s)-$(uname -m)" -o /usr/local/bin/docker-compose</code></pre>
                <p>Dass Compose später auch problemlos ausführbar ist empfiehlt es sich vor erster Benutzung noch die Zugriffsrechte zu ändern:</p>
                  <pre><code class="language-bash">$ sudo chmod +x /usr/local/bin/docker-compose</code></pre>
                
            <hr class="hr-dash my-7">
              
               <h4>Möglichkeit 2 - direkte Installation per apt</h4>
                <p>Die offizielle Docker-Dokumentation empfiehlt die Installation per apt von deren Seite. Hierfür solltest du zunächst dein apt-manager updaten:</p>
                  <pre><code class="language-bash">$ sudo apt-get update</code></pre>
                <p>Im Anschluss kannst du Docker und die dependencies herunterladen:</p>
                  <pre><code class="language-bash">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre>
                <p>Auch hier musst du im Anschluss den normalen User mit Docker verknüpfen und mit einem Neustart bestätigen:</p>
                  <pre><code class="language-bash">$ sudo usermod -aG docker $USER</code></pre>
                <p>Nun kannst du mit einem der folgenden Befehle testen, ob alles richtig eingerichtet wurde:</p>
                  <pre class="line-numbers"><code class="language-docker">$ docker run hello world
$ docker --version</code></pre>


            <hr class="hr-dash my-7">


            <h3 id="setup_u2">Docker auf Windows/Mac installieren</h3>
            <div class="video-wrapper ratio-16x9">
                <iframe width="560" height="315" src="https://www.youtube.com/embed/AzXzZqIgmkE?controls=0&showinfo=0&rel=0" frameborder="0" modestbranding="1" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture " allowfullscreen></iframe>
              </div>
              
            <p>Für Windows und Mac stellt Docker eine Desktop-Version mit verschiedenen Vorteilen bereit. So ist Docker Compose bereits in der Installation inbegriffen, Updates müssen nicht von Hand installiert werden und die Installation ist im Allgemeinen deutlich einfacher.
              Für die Installation ist eine Anmeldung bei Docker Hub erforderlich, dies ist allerdings nicht schlimm, da man für den späteren Arbeitsverlauf mit Docker sowieso ein Account benötigt.
              Unter folgendem <a href="https://www.docker.com/products/docker-desktop" target="blank">Link</a> kannst du Docker Desktop für Mac oder Windows herunterladen.</p>
            <br>
            <p>Unter Windows kann es je nach Alter oder Konfiguration deines Gerätes zu schwierigkeiten kommen. Wichtig ist, dass Windows Hypervisor (Hyper-V) von deinem Prozessor unterstützt wird. Dies siehst du am besten, wenn du unter “Ausführen” (windows + R)  nach “optionalFeatures” suchst. 
              Ist in dem anschließend zu sehenden Fenster die Option “Hyper-V” ausgegraut kannst du Docker nur bedingt benutzen (Modus für Windows-Container). Ein problemloses Arbeiten über verschiedene Setups hinaus ist dadurch nicht möglich.
              Wird Hyper-V von deinem Prozessor allerdings unterstützt kannst du nach der Installation ohne große Einrichtung loslegen. 
              Auch Mac benötigt einige Voraussetzungen. Dein Gerät sollte mindestens aus dem Jahr 2010 sein und mindestens mit macOS yosemite laufen. 
              Als Test kannst du im Terminal einfach mal folgende Befehle zum Test ausführen:</p>
            <pre class="line-numbers"><code class="language-docker">$ docker --version
$ docker-compose --version
$ docker-machine --version</code></pre>


            <hr class="hr-dash my-7">


            <!--
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            | Images und Container
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            !-->
            <h2 id="images">Images und Container</h2>
            <p class="lead-2">In diesem Kapitel lernst du was der Unterschied von Container und Images ist und wie diese funktionieren.</p>


            <hr class="hr-dash my-7">

            <p>Bevor man die Funktionsweise von Docker-Containern beschreibt ist es wichtig zuerst zwischen einem Docker-Container und einem Docker-Image zu unterscheiden. Grundsätzlich beruhen alle Docker-Container auf Images. Images sind sozusagen der Bauplan für den späteren Container. In dem Image sind alle Abhängigkeiten, die ein Container für den ordnungsgemäßen Betrieb braucht, hinterlegt. Die Images können ganz einfach über Docker Hub oder auch GitHub heruntergeladen werden. Nachdem das Image auf dem lokalen PC liegt kann es gestartet werden. Der nun laufende Prozess wird jetzt aber als Container bezeichnet. Es handelt sich also ähnlich wie bei der Magma/Lava Thematik nur um eine Eigenschaft, die zu der Namensänderung führt. Container können jedoch noch beliebig angepasst und manipuliert werden. Wird ein Container gestoppt und ein neuer Container aus dem gleichen Image erzeugt nimmt er die Veränderungen, die im Container gemacht wurden jedoch nicht an.</p>

            <p>Kurz gesagt: Docker-Container sind laufende Prozesse, die auf dem Abbild von Docker-Images basieren. Im nächsten Kapitel wird das erste Image ausgeführt.</p>



            <hr class="hr-dash my-7">



            <!--
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            | Hello World
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            !-->
            <h2 id="helloworld">Hello World</h2>
            <p class="lead-2">In diesem Abschnitt wirst du die ersten Praxis-Schritte mit Docker machen. Im Details lernst du:</p>
              <ul class="lead-2">
                <li>Das Ausführen eines Hello-World-Containers</li>
                <li>Das Erstellen eines eigenen Images</li>
                <li>Dateien Mappen</li>
                <li>Docker Volumes</li>
                <li>Der Aufbau eines Dockerfile</li>
                <li>Das Arbeiten mit Datencontainern</li>
              </ul>
            

            <hr class="hr-dash my-7">

            <p>Mit der Installation von Docker wurde auch das Command-Line-Interface (Docker-cli) installiert. Es handelt sich hierbei und eine Befehlsbibliothek mit allen Funktionen rund um Docker. Dieses macht das Arbeiten mit Container, Images und Co erst möglich. Aufrufen kannst du das Docker-cli mit dem Schlagwort <code>$ docker</code>. Darauf folgt dann der eigentliche Command. Die Docker Befehle lassen sich in drei Gruppen aufteilen:</p>
            <ul>
              <li>Das Arbeiten mit Containern (z.B. <code>$ docker run</code> oder <code>$ docker  ps</code>)</li>
              <li>Das Manipulieren von Images (z.B. <code>$ docker build</code>)</li>
              <li>Das Verbinden mit Docker-Hub (z.B. <code>$ docker pull</code> oder <code>$ docker login</code>)</li>
            </ul>
            <p>Nach den Command folgen meist noch Parameter oder Argumente. Für was genau die einzelnen Befehle stehen erfährst du natürlich mit dem Bearbeiten der einzelnen Kapitel.</p>
            <hr class="hr-dash my-7">

            <h3 id="helloworld_u1">So führst du ein Hello-World-Container aus</h3>
            <p>Zum besseren Einstieg in Docker gibt es ein vorgefertigtes Image mit dem Namen hello-world. Mit folgenden Befehl startest du aus dem Image heraus einen Container:</p>
              <pre><code class="language-docker">$ docker run hello-world</code></pre>
            <p>Darauf hin dürfte folgende message zu sehen sein:</p>
              <pre class="line-numbers"><code class="language-docker">Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
  1. The Docker client contacted the Docker daemon.
  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
  3. The Docker daemon created a new container from that image which runs the 
     executable that produces the output you are currently reading.
  4. The Docker daemon streamed that output to the Docker client, which sent it 
     to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
  $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
  https://hub.docker.com/

For more examples and ideas, visit:
  https://docs.docker.com/get-started/</code></pre>

            <p>Wie in der zweiten Zeile zu lesen ist, verlief die Installation von Docker problemlos. Außerdem wird beschrieben, wie das hello-world image von Docker-Hub gepullt und ausgeführt wurde. Dies ist ein Workflow, der dir auf deinem weiteren Weg mit Docker noch öfters über den Weg läuft.<br>
              Alle deine Docker-Container anzeigen kannst du mit diesem Befehl:
            </p>
              <pre><code class="language-docker">$ docker ps</code></pre>
            <p>Dein eben ausgeführtes hello-world wird nun nicht angezeigt werden, da es nach dem Ausführen direkt wieder beendet wurde.<br>
               Mit dem Befehl <code>$ docker images</code> kannst du alle auf deinem Setup existierenden images anzeigen. Dort sollte nun auch das hello-world image zu sehen sein.<br>
               Außerdem kannst du mit dem Befehl <code>$ docker ps -a</code> auch die gestoppten Container sehen. Wenn du nun noch einmal den hello-world-Container mit docker run erzeugst und dir im Anschluss alle Container anzeigen lässt siehst du, dass durch jeden docker run befehl ein neuer Container erzeugt wird, allerdings beide auf dem gleichen Image beruhen.
            </p>
              
            <hr class="hr-dash my-7">


             <!--
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            | Eigenes Image erstellen
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            !-->
            <h2 id="image_erstellen">Eigenes Image erstellen</h2>
            <p class="lead-2">In diesem Abschnitt erfährst du wie du ein eigenes Docker-Images erstellst.</p>

            <hr class="hr-dash my-7">

            <p>Wie du nun schon gelernt hast kannst du mit dem Befehl <code>$ docker run</code> Container starten. Hierbei gibt es noch einige Parameter, die diesen Schritt etwas umfänglicher machen. So kannst du beispielsweise mit <code>--name</code> deinem Container einen Namen geben. Mit dem Parameter <code>-it</code> wird ein sog. interactive terminal geöffnet.<br>
               In der Praxis kann das ganze dann folgendermaßen aussehen:
            </p>
              <pre><code class="language-docker">$ docker run -it --name containername ubuntu:14.04 /bin/bash</code></pre>
            <p>Der Container wird gestartet. Lässt man sich nun mit <code>ls -la</code> die Inhalte des Containers ausgeben, in dem man sich nun befindest erkennt man, dass es sich um eine isolierte Linux-umgebung handelt (ubuntu 14.04). Durch das bash am Ende des Befehls wird definiert, dass sich das ganze in einer bash-shell öffnen soll.<br>
               Dies ist nun unser Basis-Image, das wir um ein darauf aufbauendes Image erweitern wollen. Das zweite Image soll Curl beinhalten. Dies wird wie üblich per apt installiert. Du solltest hierzu natürlich sichergehen, dass du dich noch in der Ubuntu-Umgebung befindest.<br>
               Das ganze sieht dann wie folgt aus:
            </p>
              <pre class="line-numbers"><code class="language-docker">root@43f656d835f4:/# apt-get update
…
root@43f656d835f4:/# apt-get install curl</code></pre>
            <p>Nun kannst du mit exit die Shell verlassen. Im folgenden werden wir die Änderungen aus der Shell committen und daraus ein neues Image erstellen.<br>
               Dies sieht Syntax-technisch zunächst aus wie bei einem Commit bei git. Der Unterschied ist allerdings, dass bei Docker nach der Commit-message noch die ID des betreffenden Containers und der Name des neuen Images anzugeben sind:
            </p>
              <pre><code class="language-docker">$ docker commit -m “Commit-Message - Curl hinzugefügt” 1234567890AB curl-image</code></pre>
            <p>Bei erfolgreicher Eingabe sollte nun die neu erzeugte Image-ID ausgegeben werden. Außerdem kannst du mit <code>$ docker image</code> sehen, ob das Image angelegt wurde.</p>
           
            <hr class="hr-dash my-7">

             
            <!--
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            | Bind-Mounts
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            !-->
            <h2 id="bind_mounts">Bind-Mounts</h2>
            <p class="lead-2">Eines der wichtigsten Features in Docker ist natürlich auch das Teilen von Daten. Den Anfang macht hier das Mappen von Daten auf Lokaler Ebene. So kann man Daten vom Host-Rechner ganz einfach in das Docker-Setup teilen oder anders herum. Wie das genau aussieht lernst du im folgenden Kapitel.</p>

            <hr class="hr-dash my-7">

            <p>Eines der wichtigsten features in Docker ist natürlich auch das Teilen von Daten. Den Anfang macht hier das Mappen von Daten auf Lokaler Ebene. So kann man Daten vom Host-Rechner ganz einfach in das Docker-Setup teilen oder anders herum. Wie das genau aussieht lernst du im folgenden Kapitel.</p>
            <p>Das Mappen von Daten ist eine gängige Methode für Test- oder Entwicklungsumgebungen auf lokaler Ebene. Dieser Vorgang wird im englischen auch "Bind-Mounts" genannt. Für größere Projekte mit mehreren Setups eignet sich diese Technik nicht besonders. Eine deutlich mobilere und bessere Methode ist hier der Einsatz von Volumes, was dies genau ist erfährst du später.  Als ersten Schritt benötigst du eine Datei, die du mappen willst. Im Beispiel wird mit einer einfachen .txt-datei gearbeitet. Diese befindet sich auf dem Host-Rechner in einem eigenen Ordner.<br>
              Die Grundlegende Syntax zu Mappen von Dateien sieht so aus:
            </p>
              <pre><code class="language-docker">$ docker run -v hostverzeichnis:dockerverzeichnis</code></pre>
            <p>Wie du siehst wird hierfür ein Container erzeugt. Um das ganze etwas anschaulicher zu machen arbeiten wir im folgenden Beispiel mit ein paar Parametern mehr.</p>
              <pre><code class="language-docker">$ docker run -it -v ~/webroot/lokal:/home/daten --name Datenparty ubuntu:14.04 /bin/bash</code></pre>
            <p>Wie du feststellen kannst öffnen wir das ganze wieder in einer isolierten Linux-Umgebung. So können wir feststellen, ob die Daten auch wirklich geteilt wurden. Außerdem nennen wir den Container zur besseren Übersicht um. Der Parameter <code>-v</code> leitet hier das Mapping ein. Darauf folgt der Pfad zum Ordner mit der gemappten Datei. Nach dem Doppelpunkt wird das Zielverzeichnis im Container definiert. Wichtig hierbei ist, dass der Ordner “daten” erst mit diesem Befehl erzeugt wird und die Daten aus dem im Befehl angegeben Host-Pfad in diesen verknüpft werden.</p>
            <p>Dass die Daten wirklich aktiv gemappt werden und nicht bloß in den Container kopiert werden kannst du auch testen. Wenn du die Datei lokal durch beispielsweise Umbenennen manipulierst und durch ein einfaches <code>$ ls</code> das Verzeichnis in deinem Container aktualisierst siehst du, dass die Dateien wirklich verknüpft sind. Natürlich funktioniert dies auch in die andere Richtung, also von Docker-Container auf Host-Verzeichnis.</p>
            
            <hr class="hr-dash my-7">

            
            <!--
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            | Docker Volumes
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            !-->
            <h2 id="volumes">Docker Volumes</h2>
            <p class="lead-2">In diesem Abscnitt lernst du was Volumes sind und wie diese erstellt, befüllt und entfernt werden. </p>

            <hr class="hr-dash my-7">
            <div class="video-wrapper ratio-16x9">
              <iframe width="560" height="315" src="https://www.youtube.com/embed/AZpNa4BneEo?controls=0" frameborder="0" frameborder="0" modestbranding="1" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture " allowfullscreen></iframe>
            </div>
            <br>
            <p>Docker Volumes ist der präferierte Weg für persistente Daten die von Docker Containern generiert und verwendet werden. Während Bind-Mounts (das Mappen von Dateien) von der Verzeichnisstruktur der Host-Maschine abhängig sind, werden die Volumes vollständig von Docker verwaltet. Volumes haben mehrere Vorteile gegenüber Bind-Mounts.</p>
            <ul>
              <li>Volumes können sicherer von mehreren Containern gemeinsam genutzt werden.</li>
              <li>Volumes sind einfacher zu sichern oder zu migrieren als Bind-Mounts.</li>
              <li>Für neue Volumes kann der Inhalt vorab mit einem Container gefüllt werden.</li>
              <li>Du kannst Volumes mithilfe von Docker-CLI-Befehlen oder der Docker-API verwalten.</li>
              <li>Volumes funktionieren sowohl auf Linux- als auch auf Windows-Containern.</li>
            </ul>
            <img src="assets/img/volumes.jpeg" class="img-fluid" alt="Responsive image">
            <p>Wenn dein Container nicht persistente Daten generiert, solltest du die Verwendung eines tmpfs-Mount in Betracht ziehen, um zu vermeiden, dass die Daten dauerhaft irgendwo gespeichert werden, und um die Leistung des Containers zu erhöhen. Weiteres über tmpfs-Mounts findest du unter docs.docker.com/storage/tmpfs/.</p>

            <h3 id="volumes_u1">Volume erstellen und verwalten</h3>
            <p>Im Gegensatz zu einem Bind-Mount kannst du Volumes außerhalb des Bereichs eines beliebigen Containers erstellen und verwalten. Hier ist eine Auflistung den gängigsten Befehlen:</p>
            <p>Erstellen eines Volumes:</p>
            <pre><code class="language-docker">$ docker volume create mein-volume</code></pre>
            <p>Volumes auflisten:</p>
            <pre><code class="language-docker">$ docker volume ls</code></pre>
            <p>Volume inspizieren:</p>
            <pre><code class="line-numbers language-bash">$ docker volume inspect my-vol
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]</code></pre>
            <p>Ein Volume entfernen:</p>
            <pre><code class="language-docker">$ docker volume rm my-vol</code></pre>
            <hr class="hr-dash my-7">
            
            <h3 id="volumes_u2">Volume mit Container starten</h3>
            <p>Wenn du einen Container mit einem noch nicht vorhandenen Volume starten, erstellt Docker das Volume für dich. Das folgende Beispiel lädt das Volume <code>html </code> in das Verzeichnis <code>/app/</code> des Containers. <code>vol-nginx</code> ist der Name des Containers.</p>
            <pre><code class="language-docker">$ docker run -d --name vol-nginx -v mein_vol:/app  nginx:latest</code></pre>
            <p>Um den Container zu stoppen und zu entfernen sind zwei Kommandos nötig. Zu beachten ist auch, dass das entfernen von einem Volume ein weiterer separater Schritt ist.</p>
            <pre><code class="language-docker">$ docker container stop vol-nginx</code></pre>
            <pre><code class="language-docker">$ docker container rm vol-nginx</code></pre>
            <pre><code class="language-docker">$ docker volume rm vol-nginx</code></pre>
            <hr class="hr-dash my-7">
            <h3 id="volumes_u3">Ein Container benutzen um ein Volume zu füllen</h3>
            <p>Wenn Sie einen Container starten, der ein neues Volume erstellt, wie oben beschrieben, und der Container Dateien oder Verzeichnisse in dem Verzeichnis hat, das gemountet werden sollen (wie <code>/app/</code> oben), wird der Inhalt des Verzeichnisses in das Volume kopiert. Der Container stellt dann das Volume bereit und verwendet es, und andere Container, die das Volume verwenden, haben auch Zugriff auf den vorgefüllten Inhalt. </p>
            <p>Um dies zu veranschaulichen, startet dieses Beispiel einen nginx Container und füllt das neue Volume <code>html</code> mit dem Inhalt des Containerverzeichnisses <code>/usr/share/nginx/html</code>, in dem Nginx seinen Standard-HTML-Inhalt speichert.</p>
            <pre><code class="language-docker">$ docker run -d --name=mein-nginx -v html:/usr/share/nginx/html nginx:latest</code></pre>
            <p>Um nach dem Ausführen des Beispiels den Container und das Volume zu löschen, kann man wieder dieselben Befehle ausführen wie im oberen Abschnitt.</p>
            <hr class="hr-dash my-7">
            <h3 id="volumes_u4">Entfernen aller Volumes</h3>
            <p>So entfernst du alle nicht verwendeten Volumes und geben Speicherplatz frei:</p>
            <pre><code class="language-docker">$ docker volume prune</code></pre>
            <hr class="hr-dash my-7">



            <!--
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            | Dockerfile
            |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
            !-->
            <h2 id="dockerfile">Dockerfile</h2>
            <p class="lead-2">In diesem Abschnitt lernst du warum das Dockerfile gebraucht wird und welche gängigen Befehle du kennen solltest. Außerdem erfährst du, wie dein erstes Image anhand des Dockerfiles konfigurieren, bauen und ausführen kannst.</p>

            <hr class="hr-dash my-7">
            <p>Das Dockerfile ist ein wichtiges Werkzeug zum automatischen Bauen von Images. Bei einem Dockerfile handelt es sich um eine simple Textdatei mit Instruktionen und Argumenten zum Aufbau der Images. Die Syntax sieht dabei wie folgt aus:</p>
              <pre><code class="language-docker">INSTRUKTION Argument</code></pre>
            <p>Die Instruktionen sind festgelegte Begriffe. Eine vollständige Übersicht zu allen Instruktionen findest du in der offiziellen Docker-Dokumentation. Einige Beispiel-Instruktionen sind <code>FROM</code> zum festlegen des Basis-image, mit <code>ENV</code> kann man Variablen setzen oder mit <code>RUN</code> Programme oder Dienste starten, die zum Erstellen des Images notwendig sind.</p>
            <img src="assets/img/dockerfile.jpeg" class="img-fluid" alt="Responsive image">
            <p>Am häufigsten generierst du vermutlich Images aus bereits bestehenden Dockerfiles beispielsweise aus dem Dockerhub. Dies geschieht mit folgendem Befehl:</p>
            <pre><code class="language-docker">$ docker build -f /dockerfile .</code></pre>
            <p>Der Parameter <code>-f</code> und der Dahinter gestellte Pfad geben den Ort des Dockerfiles an. Der Punkt am Ende des Befehls sorgt dafür, dass das Image im gleichen Verzeichnis wie das Dockerfile erzeugt wird</p>
            <p>Eine weitergeführte Alternative ist der Parameter <code>-t</code>. Mit diesem kann man das daraus erstellte Image beliebig benennen.</p>
            <p>In der Praxis sieht das folgendermaßen aus:</p>
            <pre><code class="language-docker">$ docker build -t repository/tag  .</code></pre>
            <p>Um besser zu verstehen wie der Workflow rund um so ein Dockerfile abläuft wird im Folgenden erklärt, wie ein einfaches Dockerfile geschrieben und ausgeführt wird.</p>
            <p>Gehe zunächst in ein beliebiges Verzeichnis auf deinem Computer. Dort wird nun das Dockerfile erstellt und mit einem beliebigen Editor (in diesem Fall vim) geöffnet:</p>
            <pre><code class="language-docker">$ touch Dockerfile</code></pre>
            <pre><code class="language-docker">$ vim Dockerfile</code></pre>
            <p>Nun wird das Dockerfile wie oben beschrieben mit Instructions und Argumenten gefüllt. Da Docker das File von Oben nach Unten abarbeitet ist es wichtig die einzelnen Instruktionen in der richtigen Reihenfolge zu setzen: </p>
            <pre class="line-numbers"><code class="language-docker">FROM ubuntu:14.04
MAINTAINER Max Mustermann <max.muster@mail.de>
RUN apt-get update
RUN apt-get install -y curl apache2
ENV MyVar="Irgendein Wert"
WORKDIR /home
VOLUME ["/var/www"]
ENTRYPOINT ["top"]</code></pre>
            <p>Natürlich gibt es durch die große Anzahl der Instruktionen auch viele Wege so ein Dockerfile aufzubauen. In unserem Beispiel wird zunächst das Basisimage mit <code>FROM</code> definiert. als zweiten Schritt wird der Urheber des Images genannt, dies ist nur konventionsbedingt, allerdings keine Pflicht. Mit <code>RUN</code> werden nun einige Dienste gestartet und mit ENV eine Umgebungsvariable initialisiert, hier könnte man beispielsweise direkt einen Port angeben.</p>
            <p>Mit <code>WORKDIR</code> wird das Arbeitsverzeichnis gesetzt und alle darauf folgenden Befehle von dort aus ausgeführt. Mit <code>VOLUME</code> kann man Verzeichnisse definieren, die nach Außen zur Verfügung gestellt werden. Am Ende setzen wir mit <code>ENTRYPOINT</code> fest, was beim Starten des Containers zuerst ausgeführt wird, in unserem Beispiel starten wir das Programm “top”. </p>
            <p>Wenn das Dokument beschrieben und gespeichert ist kann man es direkt mit dem bereits kennengelernten Befehl ausführen:</p>
            <pre><code class="language-docker">$ docker build -t repository/image .</code></pre>
            <p>Wenn alles gut läuft wird nun der build-prozess sichtbar und man erkennt, wie da Dockerfile schritt für schritt abgearbeitet wird.</p>
            <p>Mit <code>$ docker images</code> sollte jetzt auch das neu angelegte image angezeigt werden. </p>
            <p>Im nächten Schritt kannst du mit <code>docker run</code> den Container starten:
            <pre><code class="language-docker">$ docker build -t repository/image .</code></pre>
            <p> Hier zeigen sich die Vorteile des Dockerfiles, da du ansonsten nichts angeben musst. Wie im File beschrieben wird nun das Programm top gestartet. Top zeigt alle laufende Prozesse und einige Metadaten an. In unserem Beispiel allerdings nur einen laufenden Prozess, und zwar der Container, in dem es ausgeführt wird.</p>
            
            <hr class="hr-dash my-7">
          </div>

        </div>
      </div>
    </main><!-- /.main-content -->


     <!-- Footer -->
     <footer class="footer">
      <div class="container">
        <div class="row gap-y align-items-center">

          <div class="col-md-9">
            <div class="nav justify-content-center justify-content-md-start">
              <a class="nav-link" href="index.html">Home</a>
              <a class="nav-link" href="impressum.html">Impressum</a>
            </div>
          </div>

          <div class="col-md-3 text-center text-md-right">
            <a href="index.html">© Docker Doc(k) <img class="container_logo" src="assets/img/color_logo.svg" alt="img"></a>
          </div>
        </div>
      </div>
    </footer><!-- /.footer -->


    <!-- Scripts -->
    <script src="assets/js/page.min.js"></script>
    <script src="assets/js/script.js"></script>

  </body>
</html>
